---
import { navigate } from 'astro:transitions/client';
interface Props {
  domain?: string;
  user?: string;
  buttonText?: string;
}

const {
  domain = 'mikeconnor.tech',
  user = 'info',
  buttonText = 'email me',
} = Astro.props;

// Pre-encode the email parts on the server-side
const encodeToEntities = (text: string) => {
  return Array.from(text)
    .map((char) => `&#${char.charCodeAt(0)};`)
    .join('');
};

const encodedUser = encodeToEntities(user);
const encodedDomain = encodeToEntities(domain);
---

<mailto-button
  data-domain={encodedDomain}
  data-user={encodedUser}
  data-text={buttonText}
>
  <button
    class="btn btn-primary"
    aria-live="polite"
    aria-label={`${buttonText}: Contact via email`}
  >
  </button>
  <span id="email-success-msg" class="sr-only" aria-live="assertive"></span>
</mailto-button>

<script>
  import { actions } from 'astro:actions';
  import { navigate } from 'astro:transitions/client';

  export class MailtoButton extends HTMLElement {
    // Decode HTML entities back to text
    private decodeEntities(encoded: string): string {
      const textarea = document.createElement('textarea');
      textarea.innerHTML = encoded;
      return textarea.value;
    }

    // Create a partially obscured version of the email parts
    private obfuscateEmailPart(encodedText: string): string {
      const decoded = this.decodeEntities(encodedText);
      if (decoded.length <= 3) return decoded;

      // Show first character and last character, obscure the middle
      const firstChar = decoded.charAt(0);
      const lastChar = decoded.charAt(decoded.length - 1);
      const middleChars = '•'.repeat(decoded.length - 2);

      return `${firstChar}${middleChars}${lastChar}`;
    }

    connectedCallback() {
      const button = this.querySelector('button');
      const srOnlyElement = this.querySelector('#email-success-msg');
      if (!button) return;

      const encodedUser = this.dataset.user;
      const encodedDomain = this.dataset.domain;

      if (!encodedUser || !encodedDomain) {
        console.error('No user or domain provided');
        return;
      }

      // Get custom button text
      const buttonText = this.dataset.text || 'email me';

      // Display obscured version for UI
      const displayUser = this.obfuscateEmailPart(encodedUser);
      const displayDomain = this.obfuscateEmailPart(encodedDomain);

      // Proper ARIA labeling with both role and meaningful text
      button.setAttribute(
        'aria-label',
        `${buttonText}: Contact via ${displayUser} at ${displayDomain.replace(/•/g, '')}`,
      );

      // Set display text with visually hidden spans for better screen reader understanding
      button.innerHTML = `
        <span>${buttonText}: </span>
        <span aria-hidden="true">${displayUser}</span>
        <span class="sr-only">partially hidden email username</span>
        <span aria-hidden="true" class="mx-1 text-gray-500">[at]</span>
        <span class="sr-only"> at </span>
        <span aria-hidden="true">${displayDomain}</span>
        <span class="sr-only">partially hidden domain name</span>
      `;

      // Add specific role and tabindex to ensure keyboard accessibility
      button.setAttribute('role', 'button');
      button.setAttribute('tabindex', '0');

      // Support both click and keyboard activation
      const activateMailto = () => {
        const user = this.decodeEntities(encodedUser);
        const domain = this.decodeEntities(encodedDomain);

        // Announce to screen readers that email client is opening
        if (srOnlyElement) {
          srOnlyElement.textContent = 'Opening your email client...';

          // Add a visual feedback element for sighted users
          const feedbackEl = document.createElement('div');
          feedbackEl.textContent = 'Opening email client...';
          feedbackEl.className =
            'fixed bottom-4 right-4 bg-green-100 text-green-800 px-4 py-2 rounded-md shadow-lg transition-opacity';
          document.body.appendChild(feedbackEl);

          // Remove both feedback elements after announcement
          setTimeout(() => {
            srOnlyElement.textContent = '';
            feedbackEl.classList.add('opacity-0');
            setTimeout(() => feedbackEl.remove(), 500);
          }, 3000);
        }

        // Create and use the actual email only on interaction
        navigate(`mailto:${user}@${domain}`);
      };

      // Handle click events
      button.addEventListener('click', (event) => {
        event.preventDefault();
        activateMailto();
      });

      // Handle keyboard events (Enter and Space)
      button.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          activateMailto();
        }
      });
    }
  }

  customElements.define('mailto-button', MailtoButton);

  declare global {
    interface HTMLElementTagNameMap {
      'mailto-button': MailtoButton;
    }
  }
</script>
